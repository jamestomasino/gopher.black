iThe vi/ex Editor, Part 9: Take Charge with Macros	
i	
i  Text-Insertion Macros	
i	
i    What These Tools Do	
i    Working Principles	
i    Time for another exercise	
i	
i  Command-Submode Macros	
i	
i    :map Macros	
i    Buffer Macros	
i    :source Macros	
i    Another Exercise	
i    Write and Read Macros	
i	
iText-Insertion Macros	
i	
iAs befits an editor with all those built-in metacharacters that	
ioperate while you are typing in text, there are two ways to create	
iyour own macros for use during text insertion.  Both can be useful	
iin the right circumstances, so you'll probably want to put them to	
iwork at times. You may not have a choice -- often the .exrc file	
ithat you may be given when you get a new Unix shell account has	
isome of these shorthand dodges built in.  These two tools have as	
imany similarities as differences, so I will expound them in	
iparallel.	
i	
iWhat These Tools Do	
i	
iBoth tools act only when you are in text-insertion submode of	
iscreen-editing mode.  Nonetheless, the commands that set them up	
iand manage them are line-mode commands like:	
i	
i  :ab ucb University of California at Berkeley	
i  :map! } Control-[k2cc	
i	
iThe two example lines above will set up two shorthand forms that	
iyou can use without further preliminaries.  The first line provides	
ithat whenever you type "ucb" as a separate word in your text, the	
ieditor will replace it with "University of California at Berkeley".	
iIt happens right on the spot, and without any special signal from	
iyou.	
i	
iThe second line is for use if you frequently discover that what you	
iare typing has become a mess, and that the mess started back on the	
iprevious line.  With this shorthand form in effect, whenever there	
iis a "}" character in what you type in, the editor removes it and	
iinstead acts as if you had typed in "Control-[k2cc". That is, the	
iControl-[ (generated by the "Escape" key on your keyboard) causes	
ithe editor to escape from text-insertion to command mode, the "k"	
icauses the cursor to move up a line, and the "2cc" removes both of	
ithe lines involved and puts you back in text-insertion mode, ready	
ito type in a replacement for those lines and continue on with your	
itext insertion.  As with the previous tool, this happens as soon as	
iyou type in the shorthand form, without any special action by you.	
i	
iNote that whitespace separates either of these setup commands into	
ithree parts.  The first part, from the start of the line up to the	
ifirst stretch of whitespace, is just the command name.  Part two,	
ibetween the first and second stretches of whitespace, is the short	
iform that you will type into the text.  The third part, everything	
ifollowing the second stretch of whitespace, is what the editor will	
iinsert (and/or execute) when you type in the short form.  Only the	
ifirst two stretches of whitespace are separators -- any later	
istretches are integral components of part three.  And whitespace	
iincludes both space characters and tabs, in any mixture.	
i	
iWorking Principles	
i	
iNow that you've seen what these two tools do, let's consider how	
ithey work:	
i	
i  :abbreviate	
i	
i(Shortest abbreviation is :ab). This tool acts when you type in a	
icertain character or string as a separate word, each end bounded by	
iwhitespace, or a punctuation character, or the start or end of a	
iline, or the start or end of an insertion.  As soon as the editor	
isees that the abbreviation is a word by itself, it replaces that	
iabbreviation with the longer word or phrase you have set as	
iequivalent.	
i	
iAs an example, you might have declared "cat" as your abbreviation	
ifor "felix domesticus". Then, wherever you type in a line such as	
i"the habits of the common cat include", the editor will promptly	
ichange it to read "the habits of the common felix domesticus	
iinclude". But there will be no such change in words that happen to	
iinclude the string "cat" in them, such as "catamaran" or	
i"concatenation". Be careful with this, because while the word	
i"catlike" will not be changed, the word "cat-like" will be.	
i	
iNeither a backslash (\) nor a control-V will quote an abbreviation	
iinto a file as itself.  Usually, the easiest way to insert an	
iabbreviation into your text is to escape from text-insertion	
isubmode (back to command submode) in the middle of typing the	
iabbreviation, then re-enter text-insertion submode and type in the	
irest of the abbreviation.  If your abbreviation is only one	
icharacter long, though, you must fall back on typing the	
iabbreviation with a letter immediately before or after it, then	
ireturning to command submode to erase the unwanted extra letter.	
i	
i  :map!	
i	
i(No editor-accepted abbreviation). Very similar to the abbreviation	
itool discussed above, but with three major differences:	
i	
iThe shorthand form defined with this command does not need to be	
ityped into your inserted text as a separate word in order to	
ioperate. Even if it is embedded within another word, the short form	
iwill disappear and its related text will be entered in its place.	
i	
iThis tool does not simply insert the related text into the file, as	
ithe :abbreviate tool does; it acts as though the user had typed in	
ithe related text instead of the short form.  That is, if there is	
ian escape character in the related text, that escape will put the	
ieditor back into command submode, and interpret any following	
icharacters as screen-mode commands.  (Unless one of those	
icharacters returns you to text insertion submode -- then characters	
ifollowing that insert-text command will be all be put into the	
ifile, unless and until there is another escape character.)  That	
imakes accidentally triggering this tool rather dangerous.	
i	
iQuoting in a character or string that you've defined as a short	
iform via this command is simple.  Type control-V before the	
imetacharacter, or the first character of the metastring, and into	
ithe text it goes. Even that may not be required if you are dealing	
iwith a metastring, and if the timeout option to the :set command is	
istill in its default state: turned on. In this case, all you need	
ito do is be sure that you take more than one full second to type in	
ithe entire metastring, and it will have no meta effect.  (This, by	
ithe way, is one reason that this tool's metastrings should be short	
i-- so you can depend on being able to type one of them in less than	
ia full second when you do want the metavalue.)	
i	
iQuestions naturally arise regarding these tools.  One frequent	
iquery is why anyone would want to mess around with :abbreviate when	
iit seems much easier to do a general substitution command when the	
idocument is complete.  That is, instead of that abbreviation I set	
iup at the start of this explanation, just run a	
i:%s/\&lt;ucb\&gt;/University of California at Berkeley/g command	
iafter all the text has been entered.  There are several reasons to	
iuse Vi's abbreviation feature instead:	
i	
iIt's not hard to unknowingly type in your abbreviated string where	
iyou don't want it expanded, as in a direct quotation (Savio told	
ithe students, "We don't want ucb to get the upper hand!"), or where	
iit has an entirely different meaning (Next, punch in the code: aQr	
iPxN ucb JHt.) Using the substitution command above, you would never	
isee that these sentences were being disfigured.  But with	
ion-the-spot replacement the mistaken use would be right in your	
iface.	
i	
iLines can get very long when abbreviations are expanded, especially	
iwhen there are several abbreviations in one line.  When you use a	
igeneral substitution command after text entry, there's no way to	
iknow that certain lines have become unreasonably long.  But with	
ithe :abbreviate tool, you see the final length of each line as you	
igo along.  And if you use the wrapmargin option to the :set	
icommand, line breaks will generally be inserted after any	
iabbreviations have been expanded.	
i	
iIt's easy to forget to run a general substitution command.  But a	
i:abbreviate command can be made automatic by putting it in a .exrc	
ifile, and the user can see while typing whether it is or is not in	
ioperation.	
i	
iThis tool can do more than save typing.  For example, suppose a	
itechnical writer is in the habit of typing "unix", while company	
ipolicy requires "UNIX(R)". Either a general substitution or the	
i:abbreviate tool will correct that writer's recurring errors, but	
ionly the latter will continuously teach him that "unix" is not to	
ibe used.  As another example, consider a writer who begins far too	
imany sentences with the word "The", which makes for dull reading. A	
i:ab The DON'T OVERDO IT! command will ensure that every time this	
iwriter types the word "The" at the start of the sentence, it will	
ipromptly be transmuted into the billboard phrase "DON'T OVERDO	
iIT!", which can be backspaced over to insert a new sentence	
ibeginning.  Note that this will not be triggered by words such as	
i"These" or "Then", nor by the word "the" in the middle of a	
isentence.	
i	
iAnother common question concerns precedence of metacharacters.  You	
ican use most of the text-input metacharacters I've discussed	
ipreviously as short-form names in :map! commands.  Suppose you did	
iuse control-D as such a short form -- what would happen when you	
ityped control-D at the start of an autoindented line?  Would it	
iwipe out the indentation or type in the phrase that :map! has	
iassociated with it?  Or if you used control-H as a short form?	
iWhen you subsequently typed a control-H during text entry, would	
ithe cursor back up a space, or would type in a stored phrase?	
i	
iThe answer is that the :map! value would prevail.  By preceding	
ieither character with a control-V, you could type in in as itself,	
ibut there would be no way to use the ordinary metavalue of either	
icharacter.  If you were to map control-D followed immediately by	
ianother control-D or two consecutive control-H characters or any	
iother doubling of an ordinary metacharacter, the situation would be	
imore complex.  You could then type the two control-D or control-Hs	
iwithin one second to get the mapped text typed in, or you could	
itype control-D or control-H followed by a one-second pause to	
iinvoke the ordinary metavalue.	
i	
iTime for another exercise.	
i	
iSuppose that you used control-D or control-H as a short form with	
ithe :abbreviate command.  Or suppose that you used some ordinary	
icharacter string as both an abbreviation and a mapping short form.	
i(The editor will allow you to do this.)  What would happen when you	
ityped in this double-use short form during text insertion?  This	
iexercise is straightforward enough that I expect most of you will	
ifind the correct answer before you look at my solution.	
i	
iTwo final warnings.  Do not try to define a non-alphanumeric	
icharacter or string as a short form with the :abbreviate command.	
iYou probably will be able to do this -- the editor won't object --	
ibut when you try to use this abbreviation, nothing will happen.	
iAnd with either :abbreviate or :map!, do not put any metacharacter	
ias itself into the long-form string.  Even if you manage to get it	
iinto the string as itself, it will not go into your text that way.	
i	
iWhat if you have forgotten what short forms you have set up, or are	
iuncertain as to whether some may have been set up for you via a	
i.exrc startup file?  Well, you can query either tool ju st by	
igiving its setup command without any arguments.  Here are examples	
iof those queries, with the responses you might receive from the	
ieditor:	
i	
i  :ab	
i  cat   cat   felix domesticus	
i  wolf  wolf  canis lupus	
i	
i  :map!	
i  {     {     ^[o^I^IThe End^[	
i  }     }     ^[o^I^I-XXX-^[	
i  ~     ~     (more to come)^[	
i	
iNote that each response line has at least three strings of printing	
icharacters, separated by whitespace.  It's that second string in a	
iline that is the short form; the string that when typed in will be	
ireplaced by the last string shown.  (Yes, in every example line	
iabove the first string is identical to the second, but that isn't	
ialways so.)  The last string is what will be inserted and/or	
iexecuted.	
i	
iSo now you know what characters and strings will have to be quoted	
iin when you want to insert them as themselves.  And if one or more	
iof those short forms is something you will be typing in so often	
ithat you can't spare the time to quote it in each time you use it,	
iyou can disable the metavalue for the rest of the present editing	
isession.  Just give the command name for the tool that uses this	
ishort form but precede it with "un", and as the only argument give	
ithe short form you want to disable. For example, here are the	
icommands that will disable the first entry in each of the lists	
iabove:	
i	
i  :unab cat	
i  :unmap! {	
i	
iCommand-Submode Macros	
i	
iIt's common that a text editor has a facility that lets a user	
icreate personalized commands, usually as macros built on existing	
icommands. The Vi/Ex editor has four such facilities -- something	
ifor every need. While these facilities don't have the low-level	
iprogrammability of mock-Lisp, they can accomplish a lot to simplify	
iyour editing, and you don't need to learn a programming language to	
iuse them.	
i	
iI'll be discussing each facility (or family) in its own section	
ibelow, because their structures are quite different.  Nonetheless,	
iyou can often combine them to go od effect, by using a macro of one	
itype to call a macro of a different type.	
i	
i  :map Macros	
i	
iThis is the editor tool that's closest to what most users think of	
ias a macro facility.  It uses the command :map as its setup tool,	
iand the macros it creates operate when the user is in command	
isubmode of screen-editing mode.  Otherwise it works just the way	
iits very close relative, the :map! tool, works -- which I explained	
iin depth in the first half of this tutorial part, above.  Consider	
ithe three command lines below:	
i	
i  :map v :!wc -w %Control-M	
i  :unmap v	
i  :map	
i	
iThe first line sets up a macro that does a word count on the file I	
iam editing, as of the last write to storage, whenever I type the	
iletter v from command submode while I am screen editing.  The	
isecond unsets that macro, so that a v command no longer does	
ianything.  The third displays a list of the :map macros that are	
icurrently in effect. All this should be transparently plain to	
ireaders who understand the :map! tool.  Still, there are a few	
ipoints worth noting that are particularly applicable to the :map	
iside of the family.	
i	
iChoosing a short-form for :map macros should not be difficult.	
iHalf a dozen of the printing ASCII characters and many of the	
icontrol characters are not used as screen-editing commands or	
iaddresses. Hardly any strings of two duplicate characters (such as	
i"DD" above) are in use, and most editor versions will let you map	
isuch strings. You don't need to avoid duplicating your :map! short	
iforms because the name spaces are completely separate.  That is, if	
iyou use a particular character or string as a :map short-form and	
ialso as a :map! short-form; for example:	
i	
i  :map }} :!wc -w %Control-M	
i  :map! }} Control-[j0R	
i	
ithere is no conflict.  The editor will allow both mappings, and	
iwill use the correct long-form based on the context; whether you	
ityped }} from command or text-insertion submode.  As the first	
iexample above shows, your command string can include any of the	
iline-mode commands that can be invoked from screen mode, providing	
iyou begin each one with a colon ":" as you would when invoking it	
idirectly while in screen mode, and quote in a Control-M (the RETURN	
icharacter) to terminate the command.	
i	
iSuppose that you ran the two following setup commands, either one	
ifirst:	
i	
i  :map Q 2dd	
i  :map V 3jQ	
i	
iThe first command clearly provides that the Q command, which	
iordinarily is the command that takes you out of screen mode and	
iinto line mode, does not do that any more.  Instead, it now deletes	
itwo lines, and you now have no way to leave screen mode without	
iunmapping the "Q" character.  But what does the new V do?	
i	
iIf you've left the :set command's remap option turned on, its	
idefault value, then the V drops down three lines and then deletes	
ithat third line and the one following.  That is, when it comes to	
ithe "Q" character in that mapping, it discovers that "Q" itself has	
ibeen mapped, and brings in the mapped value of "Q". But if you had	
ipreviously run a :se noremap command, then the editor would not	
icheck for any mappings of the characters within a macro, and would	
iuse the standard meaning of "Q" when it executed the "V" macro.  So	
ithen typing a "V" character would move you down three lines and	
ithen put you into line-editing mode.  (Yes, that means that while	
iyou would no longer be able to execute the Q as itself directly,	
iyour macros could still access it!)	
i	
iBuffer Macros	
i	
iThere are limits to the amount of macro text you can store by	
imapping it -- not as severe now as with earlier versions of the	
ieditor, but still somewhat confining.  To remedy that, the editor	
ioffers a quite-similar tool with practically unlimited storage.  It	
iinvolves those buffers where you store text pulled from your file,	
ifor later reinsertion at various places.  Specifically I mean the	
itwenty-six buffers named "a" through "z".	
i	
iFrom screen-editing command sub-mode, you can type an at-sign "@"	
ifollowed by a letter of the alphabet, and the editor will take the	
icontents of the buffer with that letter-name and execute it as a	
iscreen-mode command string.  For example, if you have "0d3w"	
i(without the quotation marks) stored in named-buffer "k", then	
ityping @k will delete the first three words on the current line.	
iAfter you start using this method in your editing session, there's	
ian extra added convenience available: typing @@ will repeat the	
ilast such buffer command you ran.	
i	
iTo put a command into a named buffer, get the line or lines of your	
icommand into your file one way or another, then delete or yank them	
iinto the buffer of your choice, as by:	
i	
i  "p3dd	
i  :ya m	
i	
ito delete a three-line macro into buffer "p" and yank a one-line	
imacro into buffer "m", respectively.  You need not tell the editor	
ithat you regard the contents of a buffer as a command macro until	
iyou choose to execute it with a "@" command.  In fact, you can use	
ia buffer's contents both ways, executing it as a command at one	
imoment and putting it back into your file as text the next.	
i	
iOne important difference from macros created by mapping: if you	
ineed a linebreak character in a buffer macro, don't try to quote it	
iin. Instead, type it in the ordinary way, so that it forms a line	
ibreak between two lines of your macro text.  And don't break a line	
iin your macro text for any other reason, because the linebreak	
icharacte r that appears there will be treated as a command	
icharacter by the editor when you execute the buffer contents as an	
iediting command string.	
i	
i  :source Macros	
i	
iLine-mode commands have a macro tool in this editor, too.  Of	
icourse you can insert most line-mode commands in the previous two	
itypes of macros, but this tool is dedicated entirely to line-mode	
icommands, and can include even commands that can't be run	
iinteractively from screen mode via a preceding colon.  The only	
iline-mode commands that can't be run with this tool are the visual	
iand open commands. With this tool, you set up your macros by	
iputting their commands into one or more files, then invoke them	
iwith command lines like:	
i	
i  :so /u/myname/commands.1	
i	
iYour command files should contain strictly line-mode commands, one	
iper line unless you separate them within the line by pipe "|"	
icharacters, and should not have a colon before each command.  The	
iother restrictions depend on how you plan to invoke your macro	
ifiles.  Ideally you should give your source commands while you are	
iin line mode -- then the above limitations are all you will face.	
iBut if you insist on invoking :source while in screen mode, there	
iare two other limitations:	
i	
iOnly the first line of your command file will execute.  Due to the	
ieditor restriction against running multi-line line-mode commands	
iwhile in screen mode, all lines after the first in your command	
ifile will be silently discarded.	
i	
iIf your first command is not complete on the first line (for	
iinstance, an append is not), even that command will not execute.	
iIn this case the failure will not be silent.	
i	
iAnother Exercise.	
i	
iSo if you want to source in command files from within screen mode,	
iit's a very good idea to create one-line command files.  But there	
iwill be a few cases where multi-line command files will be a	
iworthwhile thing, even when you may be invoking them from screen	
imode.  Here's an easy exercise for you: come up with a specific	
icase in which a command file that you may source in from either	
iline or screen mode should nonetheless have more than one line.  Of	
icourse there are multiple possibilities here, so don't be disturbed	
iif the solution that occurs to you is not one of those I	
iarbitrarily chose for my answer.	
i	
iWhen you really get into sourcing, you'll be pleased to know that	
i:source files can contain commands to call other :source files.	
iThis is the basis for truly modular editor scripts, and for a raft	
iof rather tricky maneuvers.  It also saves typing when you need to	
iinvoke a source file from screen mode, but the list of commands is	
isimply too long to fit on one line: a single line in your initial	
isource file is long enough to call a very large number of other	
isource files, each with a single long line of commands. You will	
iprobably find that invoking nested :source files from line mode	
iwill turn off line mode's colon prompt, but you can turn it back on	
iagain via a :se prompt command.	
i	
iWrite and Read Macros	
i	
iThe Vi/Ex editor has tools for running some or all of the lines in	
ithe file you're editing through a program outside the editor, then	
iusing the transformed lines to replace the original lines in your	
ifile. It can also run a program with any or no input and insert the	
iprogram's output in your file, or write some or all of your file	
ilines as input to a program that may send its output anywhere.	
i	
iAnd where is the macro capability in all this?  Well, when you use	
ithese tools you are not limited to standard Unix utilities as your	
ioutside programs -- your own coding will do just as well.  Compiled	
ior scripted, one line or a thousand, in a standard language like C	
ior Perl or in a specialized one such as Snobol; the rule is that if	
iyour Unix system will execute it, the editor can pass it over your	
itext.	
i	
iThis tutorial is not going to get into writing these personal text	
iprocessors, in any language, so I will only be explaining how to	
isend your text in and/or out via editor tools.  In the examples	
ibelow, I will suppose you have a text-processing program named	
imyhack that lives within your searchpath.	
i	
i[Editor's note: One external program I use frequently reformats	
iparagraphs into nicely looking text blocks that are easier to read.	
iI use the program named reform, published on pages 320-321 in the	
ifirst edition of the famous book Programming Perl by Larry Wall and	
iRandal L. Schwartz.  At first blush you may ask, why use such an	
iexternal program when I can simply set Vi's wrapmargin variable?	
iOf course, the answer is how do you easily reform paragraphs that	
iare already ragged, say due to the problem Walter posed above	
i(using find and replace to expand abbreviations, instead of	
iexpanding abbreviations using the built-in Vi abbreviation macro	
ifacility?]	
i	
iNote that the command to execute the outside program should be	
ityped as you would type it at your shell prompt, because it will be	
ipassed to the shell intact except for the addition of input and/or	
ioutput redirection.	
i	
iIf you want to take some (or all) of the lines out of your file,	
iuse them as input to your outside program, then put the resulting	
ioutput in place of the original lines, you can use either a	
iline-mode or a screen-mode command to do it, as shown below:	
i	
i  :196,254 ! myhack -n6	
i  !L myhack -n6	
i  12!! myhack -n6	
i  !/^CHAPTER/- myhack -n6	
i	
iThe line-mode command can be invoked from line mode, or from screen	
imode by preceding it with a colon.  In either case, you give an	
iaddress or address range, next the exclamation point, then	
ieverything following until you type return is passed to the shell	
ias a command line. The line-mode command must have at least one	
iaddress because there is no default address for this command.  But	
ithe whitespace I show before and after the exclamation point is	
ipermissible but not necessary; I put it in solely for readability.	
i	
iScreen-mode command form is the exclamation point as the command	
iname, followed by the target address, then the outside command	
i(with arguments and/or whitespace as would be required or permitted	
ion your shell command line), ending when you hit the escape or	
ireturn key. As with the c d y commands, you can type two	
iconsecutive exclamation points to send just the current line, and	
iuse a count to send that number of lines as shown in my third	
iexample command.  The last example involves an extra escape	
icharacter -- at the end of a search pattern address, whether / or ?	
ibased and including any + or - suffix, you must press the escape	
ikey before you start typing the outside command.	
i	
iYou're not limited to just one outside program at a time.  You can	
ipipeline two or more together as your shell permits, ordinarily	
iwith the "|" character.  (Because a | character and what follows it	
iwill be passed to the shell, this editor command cannot appear in a	
iline-mode command string, including a :global string, unless it is	
ithe last command in the string.)  The final output of the pipeline	
iis what will go into your file.  And you can undo the effect of the	
ioutside command or pipeline, putting your file back the way it was,	
iwith a u command.	
i	
iYou may not want your text to make a round trip, though.  You may	
iwant to send your text, as modified by your outside program, off to	
isome other destination, or you may want to pull some text into your	
ifile that originated in your outside program, or was taken from	
isome outside source. In these cases, use the line-mode commands	
ithat appear below:	
i	
i  :1,.w ! myhack -n6 &gt; nufile	
i  :217r ! myhack -n6 &lt; oldfile	
i	
iThe first command above sends the initial lines from the file you	
iare editing as input to your myhack program, and redirects the	
ioutput to a file.  It does not erase the affected lines from the	
ifile you are editing.  The second runs your myhack program using	
ithe contents of another file as the input, then places the output	
iin the file you are editing, right after line 217.	
i	
iBoth line-mode commands are shown with addresses, but they are not	
inecessary.  The default address for a :write command is the entire	
ifile; for a :read command, right after the current line.  The space	
icharacter just before the exclamation-point flag after each command	
iis absolutely essential; without it you would get something greatly	
idifferent from what you expected.	
i	
iUsually there will be output redirection for the :write ! command,	
iand input redirection for the :read ! command, but not always.  For	
iexample, you may want to :read ! an outside command that generates	
ia pseudo-random number, using no input at all.  When you do need	
iinput or output, you can build the necessary redirection into your	
ioutside program or you can put the redirection on the command line	
ias shown above, using your own shell's notation.	
i	
iIn The Next Installment of this Tutorial	
i	
iI'll be putting the techniques I've taught so far to work, showing	
ihow to set up the editor for special purposes.  Your suggestions on	
iwhat special purposes to consider are welcome, of course.  One	
ipurpose that is already in my mind is an arrangement of the editor	
ifor computerphobes: very simple, with beginner features such as	
i"stateless" editing, and fortified against common user errors.	
i	
iSIDEBAR: The timeout Function	
i	
iThe :set command's timeout option seems arcane in purpose and	
itricky to use, at least to some editor users.  But it becomes	
ipretty plain when you know why and how it actually works.	
i	
iBasically, when the timeout option is on (its default state) and	
iyou type in a short form you've set up by a :map or :map! command,	
iyou must type the entire short form in no more than one second.  If	
iyou miss that deadline, the editor will ignore the metavalue, and	
itake the characters you've typed at their face value.	
i	
iThis odd requirement serves a purpose; preventing deadlock.  As an	
iexample, suppose you have defined "DD" (without the quotation	
imarks) as a macro via the :map command, and have turned off the	
itimeout option.  Now, while editing, you type a plain D command to	
idelete part of a line.  When the editor receives this single "D" it	
iis uncertain what to do.  Are you actually telling it to delete	
ithat partial line?  Or are you starting to type in your double-D	
imacro?  The only way the editor can resolve this question is to	
iwait and see what character you type in next.  But if you are	
iwaiting to see the result of your deletion before you do any more	
iediting, the mutual wait will last indefinitely.  With the timeout	
ioption left turned on, the wait will only be a second or so before	
ithe editor acts on your D command.	
i	
iOne moral of this story is to leave timeout on unless you have a	
icompelling reason to turn it off, and choose your macro names so	
ithat you can easily type them in within the one-second limit.  If	
iyou are not particularly nimble fingered, or if other people may be	
iusing your editor macros, then for practical purposes this means	
ieither a single character or two repetitions of one character as in	
imy example above. (Some fussy versions of the editor will refuse to	
imap anything except a single character.)	
i	
iAnother moral is to avoid certain macro names, such as "jj" (again,	
iwithout the quotation marks).  The standard address j is one that	
iyou might want to type twice in rapid succession, to move directly	
idown two lines without the trouble of reaching away from the	
icentral keyboard to hit the 2 key.  But the user with a macro named	
ijj had better not move down too quickly via that method, or he/she	
iwill accidentally invoke the macro of that name.	
i	
iFinally, you should realize that the one-second count before timing	
iout is not hair-splittingly accurate.  The design of the standard	
iUnix software clock means that the time-out interval may be a	
ilittle less or somewhat more than precisely one second.	
i	
1Back to the index	/archive/vi/
