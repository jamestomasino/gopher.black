iThe vi/ex Editor, Part 4: The Subtle Substitute Command
i
i  Making Changes Within Lines
i  A Few More Metacharacters
i  Replacement-Pattern Metacharacters
i  Other Uses for Substitution
i  A Start on Script Writing
i  Don't Lose Your Files
i  Reader Feedback
i  The Next Installment
i
iAfter the :global  command, which we discussed in the previous
iinstallment of this tutorial series, the :substitute command is
iline mode's most subtle and complex tool.  When I've gone over
ithose complexities we'll be ready to deal with techniques and
itricks of building powerful line-mode command strings.
i
iMaking Changes Within Lines
i
iMost of you already know the :substitute 
icommand by its shortest abbreviation :s 
iand use it in roughly this form: 
i
i  s/previous/former/
i  %s/Smith/Lee and Smith/
i
ito make some change within the line you are on, in the first case,
ior change every instance in the file in the second.  If you use
iboth forms you are already ahead of the game.  Too many class
iinstructors and textbook writers try to tell you that the way to
ichange some phrase throughout the file is to type something like:
i
i  global/Smith/s//Lee and Smith/
i
iThis is wasteful nonsense.  Both forms accomplish exactly the same
ithing, but the second version involves extra typing for you and an
iextra run through the file for your computer.  It does not matter
ithat not every line in your file will contain a "Smith" to be
ichanged -- the :substitute  command will execute properly in
ieither version, and quietly if even one line in the file has a
i"Smith" it can change.
i
iBut neither form as it stands  is sure to change every "Smith" in
ithe file.  The :substitute command is set up to change only the
ifirst example of the string it finds on any particular line, so a
iline in the text that originally read:
i
i  inure to Smith's benefit only if Smith shall
i
iwill be changed by either version of the command to read:
i
i  inure to Lee and Smith's benefit only if Smith shall
i
iLine mode has a built-in solution for this problem: place a
ilower-case letter "g" at the very end of the command, immediately
iafter the last "/" mark, in order to make the change on every such
istring in each line.  So typing this:
i
i  % substitute /Smith/Lee and Smith/g
i
iwill make that text line come out as:
i
i  inure to Lee and Smith's benefit only if Lee and Smith shall
i
iFiner tuning of the instances can be done by a little trickery.
iSuppose you are working on tables, and want to change only the
ivery last "k37" on each line to "q53". This command will do it:
i
i  % substitute /\(..*\)k37/\1q53
i
iIf this seems surprising, remember that in a search pattern with a
iwild card, the editor always extends the match to the greatest
ilength it can.  In this case that means the string starting at the
ibeginning of the line and ending with the last "k37" in the line.
i
iNow you should be able to extend this example.  What command would
ichange only the second-to-last "k37" on each line?  This requires
ia shrewd guess from you, so I've written a solution you can
icompare to your own.
i
iA Few More Metacharacters
i
iYou probably already know that you don't always have to type the
isearch pattern that indicates the text to be replaced by a
isubstitution command.  If you want to reuse your very last search
ipattern, whether that was in a substitution command or not, you
ican use an empty search pattern string to stand for the last
isearch pattern, so the two commands below are actually identical.
i
i  /Murphy/ substitute /Murphy/Thatcher/
i  /Murphy/ substitute //Thatcher/
i
iEither command will go to the next line containing "Murphy" and
ithere replace the first "Murphy" with "Thatcher".
i
iWithin a substitution command's search pattern to find the text to
ibe removed, all the normal search-pattern metacharacters apply.
iSo do two more that are reserved only for substitution commands:
ithe "\(" and "\)" metacharacters.
i
iThese two metacharacters don't match anything themselves, so:
i
i  substitute /^The cat and small dog show/
i  substitute /^The \(cat\) and \(small dog\) show/
i
iare exactly the same command as far as they go.  But the
isubstitution command remembers what it finds to match the text
ibetween a pair of "\(" and "\)" metacharacters, for use in the
ireplacement text.  Whenever your replacement pattern contains "\1"
ithe editor replaces that metacharacter with whatever matched the
icharacters that were between the first pair of "\(" and "\)"
imetacharacters.  A "\2" in the replacement pattern is removed and
ireplaced by whatever was matched the characters between the second
ipair.  And so on -- you can have up to nine pairs in one
isubstitution command.  These metacharacter pairs can even be
inested in the to-be-replaced text; the one that starts first will
ibe represented by "\1" and so on.  So if you extend that second
isubstitution command above to read:
i
i  substitute /^The \(cat\) and \(small dog\) show/My \2-\1 fair
i
ithe substitution command will produce a line that begins: 
i
i  My small dog-cat fair
i
iOr if you type:
i
i  substitute :up \(and \)\(over \)\(the sky\):\2\1\2\1\2\3
i
ithen your command will change the first line below to read as the
isecond line, just beneath it: 
i
i  up and over the sky
i  over and over and over the sky
i
i(I used the colon ":" character to separate the parts of the
icommand, instead of the slash "/" character, solely to make it
imore readable for you.  There is no danger of the editor confusing
i"/" with "\" or "l" (el) with "1" (one) etcetera.)
i
iAs the preceding examples show, the "\(" and "\)" are not too
iuseful with plain-text search patterns; about their only real
ivalue there is when you are searching for something that's
idifficult to spell correctly, and don't want to type it into the
ireplacement pattern with possible spelling errors.  (Spelling
ierrors aren't so dangerous in the to-be-replaced text, because
ithey only cause the pattern match to fail.)
i
iThese metacharacters save the day, though, when you are dealing
iwith other search metacharacters in searching for text that you
iwill want to put back in.  (Often the only way to specify the
iexact spot you want the replacement done is to include some
ineighboring text in the search pattern, and tell the editor that
iafter the neighboring text has been taken out it is to be put back
iin right where it was.)  Here are three examples of this kind of
isubstitution:
i
i  % substitute :\([Ss]ection\) \([0-9][0-9]*\):\1 No. \2:g
i  /\([Ss]ection\) \([0-9][0-9]*\)/ substitute ::\1 No. \2
i  % substitute ,[Aa]nswer: \([TtFf] \),ANSWER: \1,g
i
iThe first of these simply inserts "No."  in the middle of phrases
ithat are section numbers, throughout the document.  But the "\("
iand "\)" notation is essential to preserve the section number in
ieach case, and also to leave unchanged the capitalization or
inoncapitalization of the first letter of "section".
i
iThe second command does the same thing, but only on the very next
iline that has a section number to change.  The surprise here is
ithat I put the "\(" and "\)" in the address pattern to find the
icorrect line. A line address doesn't use these metacharacters, of
icourse, but it does not object to them, either.  It just ignores
ithem in its own line search, but does pass them along when a
ifollowing substitution command reuses the last search pattern, as
ihappens in this example.
i
iThe third example is useful in editing a list of answers to
iexercises. It stops at each answer to a true-or-false question and
icapitalizes the entire word "answer". The innovative aspect of
ithis command is that it finds the letter "T" or "t" or "F" or "f"
ifollowing the word "answer", so it will not change the
icapitalization where an answer is numerical rather than true or
ifalse.  And yet, the letter indicating whether "true" or "false"
iis the correct answer is not discarded as a side effect.  This is
iprimarily an example of a change that can be done more simply by
iusing other metacharacters in the replacement pattern. Those other
imetacharacters are described below.
i
iReplacement-Pattern Metacharacters
i
iThe string of characters you want to put in via a substitution
icommand can use its own list of metacharacters.  They're entirely
idifferent from the metacharacters used in searching for a pattern
iyou want to take out of a line.
i
i&
i
i  In a replacement pattern, the "&" stands for the entire text
i  that was to be replaced.  Use this when you want to add rather
i  than replace text.  For example, to change "kit" to "kit and
i  kaboodle" regardless of whether "kit" is capitalized, use:
i
i    % substitute /[Kk]it/& and kaboodle/g
i
i  If you have magic turned off, you must backslash the "&" to give
i  it metavalue.  With magic  on, backslash an "&" to insert it as
i  a regular character. (See the explanation of set in the
i  subsequent article).
i
i~
i
i  The "~" character represents the replacement pattern you used in
i  your last substitution command.  One good use for this is in
i  correcting various misspellings of a single word: 
i
i    % substitute /[Ff]anstock clip/Fahnestock clip/g
i    % substitute /[Ff]ahnstock clip/~/g
i    % substitute /[Ff]ahnstocke clip/~/g
i    % substitute /[Ff]annstock clip/~/g
i    % substitute /[Ff]anestock clip/~/g
i    % substitute /[Ff]aenstock clip/~/g
i
i  If you have magic turned off, you must backslash the "~" to give
i  it metavalue.  With magic on, backslash a "~" to insert it as a
i  regular character.
i
i\U
i
i  A "\U" metacharacter makes all letters following it into
i  capitals; to the end of the replacement pattern or until another
i  metacharacter turns it off.  Here's how you'd use it to change a
i  section of your document to all capitals:
i
i    1 , substitute /.*/\U&
i
i\L
i
i  A "\L" gives the opposite effect of a "\U"; all following
i  letters become lower case.  You might use this to decapitalize
i  acronyms:
i
i    % substitute /FORTRAN and COBOL/\L&/g
i
i\E
i
i  Use "\E" to end the effect of a "\U" or "\L" metacharacter.
i  Everything following the "\E" has the same mix of capitalization
i  as originally.  For example, to enclose a line of text in curly
i  braces, and also change just the first word to all capitals: 
i
i    substitute :\([^ ]*\)\(.*\):{\U\1\E\2}
i
i  No "\E" is needed when you switch from "\U" to "\L" in the
i  middle of a replacement pattern, or vice versa.  When either of
i  those metacharacters appears, it automatically ends the effect
i  of the other. So if you have a list of book titles, one title
i  per line, with only the first letters of the words capitalized,
i  and you want to change those titles to all capitals before the
i  colon in the middle of each title, and all lower case after it,
i  just type: 
i
i    % substitute ,\(.*\):\(.*\),\U\1:\L\2
i
i\u
i
i  This metacharacter capitalizes just the single letter that
i  immediately follows it.  If the character that immediately
i  follows it is not an alphabet letter, "\u" does nothing.
i
i\l
i
i  The same as "\u", except that "\l" makes the immediately
i  following letter come out as lower case.
i
iOne more thing that's important to know about reusing patterns in
isubstitution commands.  When all or part of a text-to-be-replaced
ipattern is going to be used as a replacement pattern, or vice
iversa, the command reuses the result of the original pattern,
iafter all the metacharacters have been evaluated in the original
isituation.  Since the metacharacters in either of those two types
iof patterns have no meaning in the other type, it could hardly be
iotherwise.
i
iBut when the reuse involves a text-to-be-replaced pattern being
iused a second time as a text-to-be-replaced pattern, or a
ireplacement pattern being reused as a replacement pattern, the
icommand brings along all the original metacharacters and evaluates
ithem afresh in the new situation.  Thus, in either of the cases in
ithis paragraph, the second use is unlikely to produce exactly the
isame results as the first use did.
i
iNow another exercise for you.  Suppose that lines 237 through 289
iof a file have unknown capitalization--any line could be all caps,
iall lower case, or some mixture.  These lines are to be changed so
ithat the first letter of every word is a capital and all other
iletters are lower case.  To simplify this, words are separated by
ispace characters.  What is the easy way to do this with one
iline-mode substitution command?  This exercise depends on
isomething I did not state directly, so don't feel bad if my
isolution is a little simpler than yours.
i
iOther Uses for Substitution
i
iDespite the name, the :substitute command doesn't always take
isomething out of the line and put something else in its place.
iHere's an example that adds text at the start of certain lines
iwithout removing anything: 
i
i  537 , 542 substitute /^/WARNING:  /
i
iso that text which originally looked like this:
i
i  The primary output line carries very high voltage, which does not
i  immediately dissipate when power to the system is turned off.
i  Therefore, after turning off the system and disconnecting the
i  power cord, discharge the primary output line to ground before
i  servicing the output section.
i
inow looks like this:
i
i  WARNING:  The primary output line carries very high voltage,
i  WARNING:  which does not immediately dissipate when power to
i  WARNING:  the system is turned off.  Therefore, after turning
i  WARNING:  off the system and disconnecting the power cord,
i  WARNING:  discharge the primary output line to ground before
i  WARNING:  servicing the output section.
i
iIt's just as practical to pull some text out of lines without
iputting anything back in its place.  Here are two command lines
ithat do just that: 
i
i  % substitute / uh,//g
i  . , $ substitute / *$
i
iThe latter command removes superfluous spaces at the ends of
ilines. It doesn't need the final two slashes because there is no
isuffix to be distinguished from a replacement pattern.
i
iAt times you might use both the previous principles, to create
i:substitute commands that neither subtract nor add any text.
iSound pointless?  Here's one such that I sometimes use when I'm
iwell along in writing one of these tutorials: 
i
i  % substitute /^$
i
iNow here's a different kind of exercise for you.  I've already
igiven you the command, above.  It obviously makes no change
iwhatsoever in the file.  So why do I run this command?  You need a
igoodly dose of inspiration to answer this, so don't be embarrassed
iif you have to look at my answer to this one.
i
iA Start on Script Writing
i
iAlready you know enough about the editor to be able to plan some
ifairly complex edits.  Here's a short introduction to the art of
iwriting editing scripts for this editor.
i
iBOTTOM-UP PROGRAMMING. That's usually the best way to build a
icomplex editor command or command script.  That's a programmer's
iterm that means putting all the little details in separately and
ithen pulling them all together into a unified whole, rather than
istarting with a grand overall plan and forcing the details to fit.
i
iFor example, reader R.T. of San Francisco, California asks how to
iuse the editor to automatically add HTML paragraph tags to each
iparagraph of manuscripts.  This requires inserting the string
i"" at the start of the first line of each paragraph, and
ithe string "" at the end of the last line.  In these
imanuscripts, a completely empty line (not even a non-printing
icharacter on it) separates one paragraph from another.
i
iThis looks pretty easy.  All that seems to be needed is to go to
ieach empty line, then move up to the preceding line to insert the
iend-of-paragraph string and down to the following line to put in
ithe start-of-paragraph string.  But there are flaws in the obvious
icommand to do this:
i
i  global /^$/ - substitute :$:: | ++ substitute /^//
i
iThe first problem is that when the editor goes to the empty first
iline that commonly begins a file, it will be unable to move up a
iline to do the first substitution.  No substitution is needed
ithere, of course, but since the editor doesn't leave that empty
ifirst line, moving down two lines will put it on the second line
iof the following paragraph -- definitely the wrong place for a
istart-of-paragraph tag.  There are several ways to fix this
iproblem:
i
iHave the editor :mark the empty line before leaving it to execute
i(or attempt to execute) the first substitution.  Then it can go to
ithe marked line (which works even if the editor never left it) and
idrop down one line to perform the second substitution.
i
iChange the address of that second substitution command from "++"
ito "/./" in order to move forward to the next nonempty line, which
iwill be the first line of the following paragraph whether the
isearch starts from the empty line or the line above it.
i
iRun two separate :global searches, each of which executes one of
ithe two substitution commands.
i
iProblem number two is that there may be several empty lines
ibetween two paragraphs, since HTML interpretation is not affected
iby them. If the editor is on the first of two or more consecutive
iempty lines, the command I first proposed above will perform its
isecond substitution on the second empty line just below it.  When
iit moves to the second previously-empty line, it will run the
ifirst substitution co mmand on the empty line it just left.  (Yes,
ithe second line is no longer empty, but it has already been marked
iby the :global command before any substitutions are done.)  That
iis, a stretch of text that initially looked like this:
i
i  at this meeting, so be sure to be there!
i
i  At next month's meeting we'll hear from the new
i
iand should have been edited to look like this:
i
i  at this meeting, so be sure to be there!
i
i  At next month's meeting we'll hear from the new
i
iactually turns out like this:
i
i  at this meeting, so be sure to be there!
i  
i  
i  At next month's meeting we'll hear from the new
i
iIt may look as though this hazard can be defeated by modifying the
inumber two solution to the first problem above.  That is, the
iaddress for both substitutions will be a search pattern that looks
ifor a line that already has some text on it.  This works properly
iwhen the editor is on the first of two consecutive empty lines.
iFrom the second line, though, it runs its substitution commands on
ilines that have already been given their tags, so the sample text
inow looks like this: 
i
i  at this meeting, so be sure to be there!
i
i  At next month's meeting we'll hear from the new
i
iCOMPLEX CONDITIONALS. What's really needed here is
idouble-conditional execution.  That is, substitution commands must
irun on a given line only if both of these conditions are true:
i
i  - The line to be substituted is adjacent to the empty line.
i
i  - The line to be substituted is not itself empty.
i
iIn this case, the editor can handle it.  The :global portion of
ithe command line takes care of the first condition if the
isubstitution commands' addresses move exactly one line in each
idirection from the empty line.  (Of the three proposed solutions
ito the first difficulty encountered, numbers one and three both do
ithis much.)  To satisfy the second condition, make the
isubstitution commands remove one character from the existing line
i-- and then replace it, of course.  This ensures that if there is
ino character to remove because the line is empty, the substitution
icommand will fail on that line and do nothing.
i
iEither the first or third solution can be adapted to satisfy that
isecond condition.  I've used the third solution in the example
icommands below, because the technique is easier to follow than it
iwould be with the first solution:
i
i  global /^$/ + substitute /^./&amp;/
i  global /^$/ - substitute :.$:&amp;:
i
iBottom-up techniques can be continued if there are yet other
ispecial needs to be accommodated.  Reader R.T. may have headlines
iand subheads mixed in with the paragraphs, and may already have
iappropriate HTML tags at the beginnings and ends of those heads
iand subheads.  As an exercise, how would you adapt the commands
ijust above so they would not add a paragraph tag where any text
ialready begins or ends with an HTML tag?  Hint -- an HTML tag
ialways begins with a "" character. This is a
ivery minor change, so you probably will not need to look at my
isolution except to confirm your own answer.
i
iA LITTLE TRICKERY. At times a command needs to be supercharged by
iway of a far out use of substitution--something perfectly
ilegitimate, but never intended by the people who wrote this
ieditor. Here are a few that you may find useful.  
i
iYou can't make a substitution that extends over more than a single
iline--not directly, that is.  Any attempt to put a "newline"
icharacter in either the to-be-replaced pattern or the replacement
ipattern of a substitution command will fail. But by combining the
iglobal and substitute commands, you can often get the effect of a
isubstitution that spills over a line ending.
i
iLet's suppose that you have to alter a long document so that all
ireferences to "Acme Distributors" are changed to "Barrett and
iSons". A simple substitution command will make most of these
ichanges, but it will miss those instances where "Acme" appears at
ithe end of one line and the next line starts with "Distributors".
iA followup pair of substitutions, to replace "Acme" wherever it
iappears at the end of a line and to replace "Distributors" when it
istarts a line, would wreak havoc--this document also refers to
i"Acme Supply Co." and to three other companies whose names end
iwith "Distributors".
i
iBut we can handle this problem nicely with the following two
icommand strings:
i
i  global /Acme$/ + substitute /^Distributors/and Sons
i  global /^and Sons/ - substitute /Acme$/Barrett
i
iThe first command goes to every line that ends with "Acme" and
ithen moves forward one line--if and only if that next line begins
iwith "Distributors", it is changed to begin with "and Sons". The
inext command reverses the process to change "Acme" to "Barrett",
ibut only in the right instances.  (Note well that the second
icommand searches for "and Sons", not "Distributors", because the
ifirst command has changed those line-split "Acme Distributors" to
i"Acme and Sons".)
i
iOften it is a good strategy to start with a change you definitely
idon't want in order to wind up with what you do want.  Suppose you
iare a technical writer who has just finished writing a number of
ilengthy photo captions full of phrases like "the light spot in the
iupper righthand corner" and "dark areas near the lower lefthand
iedge". Along comes the news that the Art Director has decided to
iflop all the photos: print them in mirror-image form.  Suddenly,
ieverything that was on the right is now on the left, and vice
iversa.
i
iYour captions will be accurate again if you change every
i"lefthand" to read "righthand" and vice versa.  But how to do that
iwithout wading through the whole text and making each change
iindividually?  The obvious pair of substitutions will not work:
i
i  % substitute /lefthand/righthand/g
i  % substitute /righthand/lefthand/g
i
iThe second command doesn't just change the original instances of
i"righthand" to "lefthand"; it also reverses every change your
ifirst command made--now everything is described as being on the
ilefthand side. But the following three substitution commands will
ido the job nicely.
i
i  % substitute /lefthand/QQQQ/g
i  % substitute /righthand/lefthand/g
i  % substitute /QQQQ/righthand/g
i
iBy making the first command change "lefthand" temporarily to
i"QQQQ" (or any other string you know will not be found in your
idocument), you keep those changes safe from the effect of your
isecond command.  Then, after that second command has finished, the
ithird command changes those Q strings to what you had wanted in
ithe first place.
i
iIt can even make sense to type in things incorrectly, then change
ithem to what you want via substitution.  When I'm writing
idocuments in plain ASCII, to be printed without any formatting, I
ioften use a line across the page to separate major sections of the
idocument.  But where others are satisfied with just a string of
ihyphens, or another single character, I pretty things up with
imulticharacter dividers like:
i
i-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
i-+--+--+--+--+--+--+--+--+--+-
i*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~
i[][][][][][][][][][][][][][][]
i
iNot that I have the patience and concentration to type in
ipage-wide lines of alternating characters, especially when I would
ihave to constantly get on and off the shift key, too.  No, I just
iuse my repeat key to fill the line with whatever character will
ibegin my eventual multicharacter pattern.  For those four patterns
iabove, I would have repeat-keyed in these four lines, respectively:
i
i------------------------------
i------------------------------
i******************************
i[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[
i
iThen I only have to run a simple repeated substitution to get the
iline I actually want.  Here are the commands I would run on the
ifour lines above, respectively:
i
i  substitute /--/-=/g
i  substitute /---/-+-/g
i  substitute /\*\*/*\~/g
i  substitute /\[\[/[]/g
i
iSEMI-AUTOMATIC SUBSTITUTIONS.  At times you'll have to make
ichanges that are so dependent on human judgment that no
isubstitution tricks could possibly do exactly what's wanted.  In
ithose cases there are two ways to have the editor partially
iautomate those changes.  
i
iThe first is to use a variant form of the substitute command that
ipresents each potential substitution on your screen, and asks you
ito accept or reject it.  All you need to do is put a lower-case
i"c" at the end of your substitution command, in the same place you
iwould put a "g" to change every instance on each line, like either
iof these examples: 
i
i  % substitute /^something/something else/c
i  % substitute /something/something else/gc
i
iThe editor will then display the lines where substitutions are to
ibe made on your screen, one at a time.  Each line will have "^"
imarks below the text to be removed, like this: 
i
i  something in the air.  The consensus is that
i  ^^^^^^^^^
i
iand if there are two or more places on the line where the
isubstitution could be performed, the line will be displayed on
iyour screen two or more times, with a different potential
isubstitution marked each time. After displaying a line on your
iscreen, the editor will wait for you to type something ending with
ia carriage return.  If whatever you type begins with a lower-case
i"y", the change will be made.  If it begins with anything else,
ithe text will be left as it is.  
i
iEven this substitution variant may not give you enough control.
iYou may need to see more than one line to verify your judgment, or
ithe text to be put in may vary from one place to another.  In
ithose cases, you can use one of the qualities of the :global
icommand.  This is a simplified version of the technique our
iprogrammer friend Hal (in the first installment of this tutorial)
iused to work over the problem points that Lint found in the code
ihe was updating.
i
iIf you are editing in screen mode, as usual, you must start by
ityping a capital "Q" to go into line mode.  From line mode's colon
iprompt, give a command like the following (if you want to make the
isame substitution as in our previous examples):
i
i  global /something/ visual
i
iThis command will bring you in turn to each line in the file that
icontains the string "something" and put you in screen-editing mode
ithere.  After you've looked around, and made a substitution if you
ithink it justified, typing a capital "Q" takes you out of
iscreen-editing mode and returns you to the global command, which
itakes you the next marked line and resumes screen editing.
i
iThere is an indirect hazard in leaving screen editing mode,
ithough.  And that brings us to the whole dismal subject of
ipreventing loss of your changes, or of your entire file, while you
iare in the editor.
i
iDon't Lose Your Files 
i
iThe vi/ex editor is not strong on protecting you from the
iconsequences of your own mistakes.  In part that's just the
inatural result of giving you a lot of editing power.  But when it
icomes to losing all the changes you've made in a file during a
isession, or even losing the original file you started with, the
ieditor could be a lot more responsible without hamstringing your
isubtle edits.  Still, there are ways you can comfortably protect
iyourself from those hazards, and many of those ways I explain
ibelow.
i
iIN EMERGENCIES. Consider one of the editor's safety features that
ican accidentally but quite easily turn into a disaster. You may
ialready know that when you edit with this editor, you are working
ion a copy of the file, not the original.  Your changes do not
iaffect the original unless you use the :write command, for which
i:w is the shortest abbreviation, or leave the editor in a normal
iway.  That's a good precaution against making a mistake with this
ipowerful editor that mangles your file, and then discovering you
ihave no backup copy.
i
iThat copy you are working on lives in a volatile place, though,
iwhere it can easily be erased when the system crashes or your link
iinto the system goes down.  That could cost you all the additions
iand changes you'd made in that session with the editor.  Your
ifirst line of defense against this is to run the :write command
ioften--every time you run it, your current edited version replaces
ithe previous version in the stable permanent-storage area on disk.  
i
iAnd if you don't intend to change the original?  Your edited
iversion is to be a new file, with the original left untouched?
iWell, you can use a modified form of writing the file, by typing
i:write nufile where "nufile" is whatever you want the name of the
iedited file to be.  (That can be a path name, in case you don't
iwant to put the new file in your current directory.)  This will
iwrite the revised version only to the new file (creating the file
iif necessary), and leave the original file untouched.
i
iThat method of preserving the original file is dangerous, though.
iIf you forget even once to add the filename to the :write command,
iyour original file is wiped off the disk.  That's why this
itechnique is best reserved for occasions where you do want to
ichange the original file, but also want a copy of some partially
iedited stage of the file saved elsewhere.  When you get the file
ito the state you want to save as a copy, run both of these
icommands:
i
i  write nufile
i  write
i
iand then go back to editing and writing to the file as usual.
i
iThe sane way to protect your original file from any changes is to
istart your editing with a :file nufile  command, for which :f
inufile  is the shortest abbreviation. From that point on, the
ieditor considers "nufile" to be the name of the file you are
iworking on, and writes go automatically to that filename.
i(Incidentally, if you ever forget whether you have changed the
ifile name, or what you've changed it to, a :file command by
iitself, without a file name, will tell you what the editor thinks
ithe file's current name is, among other interesting facts.)  
i
iCRASHES WILL HAPPEN. Still, a crash may catch you by surprise,
iwith a lot of additions and changes that you have not written to
iany file.  To protect against this, the editor always attempts to
isave your current working copy of the file when a crash is
iimminent.  You can even launch an emergency save yourself when you
iface a sticky situation, such as being unable to do a normal write
ibecause it would exceed your filespace quota.  Just type a
i:preserve command (or its :pre abbreviation) and the working copy
iis normally preserved.  There are a few gotchas to watch for,
ithough.
i
iThe preservation function puts the saved copy in a specific
idirectory, and it will fail if that directory does not exist or is
inot writable.  (The path name of that directory varies between
iversions of the editor, although /var/preserve seems to be a
icommon choice on modern Unix systems.)  To check writability, run
ia :preserve command from a short file, as a test.  If the result
iis a message something like this:
i
i  Can't open /var/preserve
i  Preserve failed!
i
ithere is a problem you will have to take up with your system
iadministrator.  (To speed up that discussion, bring along the path
iname of the directory that couldn't be opened.)  If the message
ireads like this:
i
i  File preserved.
i
iso far, so good.  The next question is whether the editor has
ipreserved an accurate copy or a pile of garbage--some editor
iimplementations are broken in this area.  To check this, recover
ithe file you've just preserved.
i
iRESCUING SAVED FILES. There are two ways to recover a rescued
iworking copy, whether it was saved in a crash or because you used
ithe :preserve command.  Usually you recover it from your shell
icommand line, by entering the editor with a "-r" flag:
i
i  vi -r novel.chap3
i  vi -r
i
iThe first of these commands puts you in the editor, with the
ilatest rescued copy of your file "novel.chap3" before you.  The
ilatter command doesn't put you in the editor at all; it displays a
ilist of all files that have been emergency-saved and then returns
iyou to the shell command line. This list is useful when, say, the
isystem crashed while you were editing a file that you hadn't given
ia name.  (Yes, you can enter the editor without giving a filename
ito edit; the editor will simply bring up an empty buffer and
iassume you will give it a name later.)  In this case the
ipreservation process will give the file a name, and you must know
ithis name to recover it.
i
iI said that the first command would bring up the latest rescued
icopy of the file you named.  If the system has been staggering for
ia while, there may be more than one occasion when either you or
ithe system caused the editor to preserve the working copy of that
ifile. If the latest version is not the best copy, you can discard
iit and pull up the next most recent version, without leaving the
ieditor. Just give a :recover command (or its :rec abbreviation) to
ihave the current rescued version discarded and replaced by the
inext-latest of the saved copies.  (When you're already in the
ieditor, there's no need to give the name of the file to recover if
iit is the same as that of the file you're editing at the time.
iThe editor assumes the current filename unless you give another
iname as an argument following the :recover command.)  If this
iisn't the best copy either, you can continue this process.
i
iWhen you've recovered a file either way, look it over.  If the
ieditor version you're using has a broken preservation function,
iyou'll only find garbage characters or a display like this:
i
i  LOST
i  LOST
i  LOST
i  LOST
i  LOST
i
iIf that be the case, the file you preserved is hopelessly lost and
iyou'd better have a talk with your system administrator about
igetting a better version of the editor.  But if what you see looks
ilike what you had, then all you have to do is write the copy
iyou've recovered to a file somewhere--the preserved copy was
ierased when you used one of the recovery commands, so it can't be
irecovered that way again.
i
iAnd that brings up the last gotcha.  You may believe that any of
ithe three commands ZZ or :x or :wq will check whether the working
icopy needs to be written to the file, write it only if necessary,
iand then quit the editor.  Actually, the last of the three, the
i:wq command, always writes to the file regardless, and is the only
ione you should use.
i
iThe first two attempt some checking, but their checks are not very
icomplete.  In particular, they and the :quit command often check
ifor nothing more than the flag that is set when an editing change
iis made to the current working copy and unset when the working
icopy is written to the file.  You are courting disaster if you
iever use the ZZ or :x commands, or if you use :quit carelessly.
i
iThe gotcha in the case of a recovered file is that pulling a new
ifile into the buffer, whether normally or by recovering an
iemergency-saved copy, is not an editing change.  If your version
iof the editor has a weak version of ZZ or :x then its casual check
iwill show no reason to write the file, and all your carefully
irecovered work will be lost for good when the command closes the
ieditor without writing the file.  So always use :wq or separate
i:write and :quit commands to end an editing session.
i
iA FEW MORE HAZARDS AND SOLUTIONS. Worse yet can befall you.  You
imay accidentally lose both your own editing changes and the
ioriginal file you were working from.
i
iSuppose one of your global editing commands went astray and
itrashed your working copy of the file, but didn't happen to affect
ithe part that is on your screen.  If you then wrote the working
icopy to the file, the garbage replaced your original file
icontents.  Oh, misery!  And with any but the smallest file, it's
inot practical to look over the working copy carefully before each
i:write command.
i
iOr perhaps you did discover the disaster before you wrote the
iworking copy to the file.  Seeing that undoing the errors was not
ifeasible, you decided either to run an :edit! command to bring up
ia fresh copy of the original file, or a :quit!  to leave the
ieditor.  In either case, the "!" at the end of the command tells
ithe editor to ignore the garbage changes that have not been
iwritten to the file.
i
iBut since you were not creating an editor script here, you
iprobably typed the short form of your command, either :e! or :q!.
iAt least you tried to.  Perilously placed between the "e" and "q"
ikeys on a standard keyboard is the "w" key.  If you accidentally
ityped :w! instead of what you intended, you told the editor to
ioverwrite the original file with that trashed version, and ignore
iany anti-write protections you may have set.  Oh, misery cubed!
i
iYou are not lost yet, though, if you have been editing along in
iscreen mode all the while.  At any time you can type a short
isequence to put the working copy back the way it was when you
istarted this editing session. Then you only need to write the
iworking copy to the file to expunge the trash there.
i
iStart by typing Q to leave screen mode and drop back to line mode.
iNow, line mode has an undo command that works the way the screen
imode u command does, but on line mode commands.  That is, it
ireverses the effect of the latest line mode command that changed
i(or may have changed) the working copy.  One line mode command
ithat may well change the working copy is visual, of course. And --
isurprise -- when you typed vi novel.chap3 from your shell prompt
ito enter the editor, your shell actually launched ex (for which vi
iis just an alias) and the editor gave itself an initial visual
icommand to boost you into screen mode.
i
iSo all the time you've been editing, the editor has been holding a
icomplete copy of the original file, in case you go back to line
imode and want to reverse the effect of that initial visual
icommand.  (That's one reason the editor's buffer takes up so much
imore room than you'd expect in swap space.)  If you want to see
ithe complete command sequence to restore the original working copy
iand return to visual mode, using shortest abbreviations and
ishowing carriage returns as new lines, here it is:
i
i  Qu
i  w
i  vi
i
iOne last hazard, which may seem childish to experienced Unix users
ibut trips up many a refugee from single user systems.  Unless
iyou're on one of those rare Unix implementations that offers file
ilocking, there is little to prevent another user on the system
ifrom editing the same file at the same time as you do.
i
iYou will each be editing on a separate working copy, so there will
ibe nothing to tell you that someone else is also editing the same
ifile.  But each time you write your changed version to the file,
iyou will wipe out whatever changes the other user has already
iwritten to file, and vice versa.  The ultimate victor in this
iunknowing war will be the user who finishes editing last. The
iother user can come back an hour later and find no indication that
ihe/she ever touched the file.
i
iThere's no real technical solution to this danger.  You'll just
ihave to coordinate carefully with other users on files that more
ithan one of you may have occasion to edit.
i
iReader Feedback
i
iOne of our readers  raised a significant point about this
itechnique; important enough to deserve a reply published in this
iarticle.
i
i  Dear Walter...
i
i  In your tutorial you write that you can use the command
i
i    global/XXX/visual
i
i  to search for the pattern "XXX" and edit/move around (remember,
i  Hal needed this command to edit the linted spaghetti-code...)
i
i  But there's one problem: suppose I found, after the 10th XXX of
i  100, that I do not want to view the remaining 90 occurences.  It
i  works as long as I don't type 'Q'. But now I want to view/edit
i  the code where my lint report is something like "illegal", I have
i  to type Q and then global/illegal/visual.
i
i  And now there's the problem: typing Q doesn't prompt for a new
i  input, it moves to the 11th occurence of "XXX".
i
i  Do you know my problem?  Is there a way to stop vi moving on with
i  the global command after typing Q?
i
i  Thanks a lot in advance!
i
i  Chris...
i
iAs Chris clearly realizes, ordinarily there is no problem with
iomitting the remaining 90 stops.  Each time this command puts you
iinto visual mode somewhere in the file, you are not restricted to
ifixing one limited problem.  You may move anywhere in the file,
iedit whatever you like, and keep doing this as long as you please.
iWhen you finally finish all the edits you've decided to do, you
ican write the file and quit the editor in your usual way--the
isuspended global command will silently disappear at this point.
i
iBut going into a second string of visual mode stops from a new
iglobal command, as Chris wants to do, requires finesse.
iObviously, it's not possible to use the Q command to return to the
iline-mode command prompt until every one of those 100 lines has
ibeen visited and the first global has terminated.
i
iThe best way out of this predicament starts with writing your
ichanges to the file.  Then, instead of typing Q type an :edit
icommand.  This brings up a fresh copy of the file you are editing,
ibut since you've just done a write, the fresh copy is identical to
ithe one you've been working on. Because you haven't left the
ieditor, most of the state is saved--contents of the named buffers,
iany maps and/or abbreviations, values of the set  command options.
iYou do wipe out a few small items like the contents of the unnamed
ibuffer--and, of course, that suspended global command.
i
iNow you can use the Q command to go into line mode, then run that
isecond global command.

1Solutions	solutions
i
iIn The Next Installment
i
iIn this tutorial to date, you've undoubtedly seen some aspects of
ithe editor that you wish had been designed differently.  The good
inews is that many of these features are yours to change at
iwill--without hacking up the source code and recompiling.
i
iIn Part 5 of this tutorial, I'll elucidate the editor's built-in
ifacilities for setting up your own editing environment, and the
imany factors you can modify this way.

1Part 5: Take Control of Your Editing Environment	/archive/vi/part5/
1Back to the index	/archive/vi/
